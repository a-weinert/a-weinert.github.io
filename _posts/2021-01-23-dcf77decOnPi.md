---
layout: weAutPost
title: DCF77 decoding on Pi
bigTitle: DCF77 with Raspberry
headline: Handling DCF77 AM signal with Raspberry Pi
permalink: /:title.html
date:   2021-01-23
categories: Raspberry Pi DCF77 decoder pigpoid
lang: en
dePage:
copyrightYear: 2021
revision: 1
reviDate: 2021-01-24
itemtype: "http://schema.org/BlogPosting"
isPost: true
published: true
commentIssueId: 9
commentShare: timeSyncLocNet.html
---
In the [post "Time synchronisation in local nets"](/timeSyncLocNet.html)
I described the uses of 
<abbr title="the callsign of the long wave time transmitter in Mainflingen">DCF77</abbr>
receivers to get the standard time from 
<abbr title="Physikalisch-Technische Bundesanstalt, Braunschweig">PTB</abbr>'s
atomic clocks. The choice of 
<abbr title="amplitude modulation">AM</abbr> receiver modules was commented
on as well as their connection to a µController like a Raspberry Pi.

Here we discuss the decoding of the DCF77 AM signal by C software on a 
Raspberry Pi. 

## The nature of the AM signal

At the begin of all seconds of a minute but the last one
the amplitude is reduced to 15% for either 100 or 200 ms.
For the rest of the one second or two second period the full (100%)
amplitude is transmitted.

The AM receivers' modules digital output is usually[<img 
src="/assets/images/goodDCF77sig_0466sm.jpg" width="426" height="248" 
title="a good DCF77 signal; click: large"  alt="a good DCF77 signal"
class="imgonright" />](/assets/images/goodDCF77sig_0466.jpg "click: large")    
  &nbsp; &bull; &nbsp; HI (1, true)&nbsp; 
      for the 15% modulation time &nbsp; and   
  &nbsp; &bull; &nbsp; LO (0, false) for the rest of the 1 or 2 s 
period.  
But it can be the other way round -- what the software should handle by,
e.g. an option -&nbsp;-&nbsp;invert.

For the modulation period    
  &nbsp; &bull; &nbsp; 200ms means true &nbsp; and     
  &nbsp; &bull; &nbsp; 100ms means false.

Hence, the information we must acquire and decode is   
  &nbsp; a) &nbsp; an 58 bit **telegram** in every minute &nbsp; and  
  &nbsp; b) &nbsp; the **start time** of the modulation period.
  
a): The telegram starts with 14 bits of secret commercial information. The
remaining 44 relevant bits contain all time and date
information. The code is simple and well published.

b): The time should be captured as exactly as possible, best as µs time stamp
with 20..50µs accuracy. With the time stamp of the modulation flank and their
DCF77 time we get the correction respectively setting of our system time --
for the use of DCF77 as our system's redundant or only time source.

So in the end, it's all about getting the **time** (time stamps) of
the modulation flanks.

## Sampling the AM signal

We can think of three approaches    
  &nbsp; A) &nbsp; read the receiver signal in the 1 ms cycle,    
  &nbsp; B) &nbsp; have an interrupt handler for both signal flanks or    
  &nbsp; C) &nbsp; exploit the abilities of pigpiod.
  
Having a runtime or framework providing 
PLC like cycles, as described in
[Raspberry for remote services](https://a-weinert.de/pub/raspberry4remoteServices.pdf
"Raspberry for remote services (.pdf, download)")
(see [publications](https://a-weinert.de/publication_en.html)) and used in
most of our controller projects, approach A is feasible. On the other hand,
when wanting DCF77 as substitute or redundancy for NTP the sync would have 
to be at least one order of magnitude better than the fastest 
cycle's timing: a reason to exclude A).

Generating sequence of time stamped events to be handled later in in an
other thread or process is per se a good approach. And an interrupt handler
(B) could do this. Raspberry processors have an interrupt system
allowing flank interrupts for
any <abbr title="general purpose input/output">GPIO</abbr>. But the
handling is complicated and the application requires sudo privileges.

A comprehensible C solution with GPIO interrupts is hardly found. Some 
libraries or frameworks employ a fast sampling thread +
interthread/interprocess communication -- and call it "interrupt".   
Well the approach is OK. It's what what A) does too slow (what could be 
mended by an extra asynchronous fast cycle) and what C) (see below) supports
perfectly. But selling it as interrupt is label fraud.

Well I'm an aficionado of Joan N.N.'s pigpiod library. See the chapter 
in question and the literature list in above mentioned 
[publication](https://a-weinert.de/pub/raspberry4remoteServices.pdf
"Raspberry for remote services (.pdf, download"). So, not surprisingly,
I exploit special abilities of a library used anyway.

<hr />

Sorry. Rest to be done soon, hopefully. 

## Capturing modulation flanks with pigpiod

cm

## Remarks on discriminating and decoding

ro

## Filtering spikes with pigpiod

fs

## An extra filter for modulation disturbances

ae

## Final remarks

fr





